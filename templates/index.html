<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Now Playing</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root{
      /* Fine‑tune these three values as you like */
      --art-margin-top: 1rem;
      --art-margin-bottom: 1rem;
      --art-margin-left: 1rem;

      --artwork-max-width: 100%;
      --artwork-max-height: 100%;
      --metadata-max-width: 35%;
      --metadata-padding: 1.5rem;
      --player-button-size: 3.5rem;
    }
    #artworkWrapper{
      margin-top: var(--art-margin-top);
      margin-bottom: var(--art-margin-bottom);
      margin-left: var(--art-margin-left);
    }
  </style>
  <script>
    function sendPlayerCommand(command) {
      fetch(`/player/${command}`)
        .then(response => {
          if (!response.ok) {
            console.error(`Failed to send command: ${command}`);
          }
        })
        .catch(err => console.error(`Error sending command: ${command}`, err));
    }

    let intervalID = null;

    function refreshData() {
      fetch(`/data?timestamp=${Date.now()}`)
        .then(response => response.json())
        .then(data => {
          // Update text fields
          document.getElementById("title").innerText = data.nowplaying.Title || "Unknown Title";
          document.getElementById("artist").innerText = data.nowplaying.Artist || "Unknown Artist";
          document.getElementById("album").innerText = data.nowplaying.Album || "Unknown Album";

          const imgElement = document.getElementById("album_art");
          const hevcUrl = data.nowplaying.HEVC && data.nowplaying.HEVC !== "None" ? data.nowplaying.HEVC : "";
          const fallbackUrl = "/static/images/cover.png";
          const staticArtworkUrl = data.nowplaying.Artwork || "";

          // Always use staticArtworkUrl for background
          const backgroundArtElem = document.getElementById("bg-image");

          // Helper constants for containers
          const imgContainer = document.getElementById("img_container");
          const videoContainer = document.getElementById("video_container");

          if (!window._lastArtworkUrl || window._lastArtworkUrl !== staticArtworkUrl) {
            window._lastArtworkUrl = staticArtworkUrl;
            if (window.updateVisualizerBackground) updateVisualizerBackground(`/static/images/cover_low.png?t=${Date.now()}`);

          }

          // Use HEVC if available, otherwise fallback to staticArtwork or default
          let finalArtworkUrl = hevcUrl || staticArtworkUrl || fallbackUrl;

          // Only update artwork/video when URL changes
          if (!window._lastDisplayedArtworkUrl || window._lastDisplayedArtworkUrl !== finalArtworkUrl) {
            window._lastDisplayedArtworkUrl = finalArtworkUrl;

          // Decide between video or image and preload image to avoid flicker
          const newSrc = `${finalArtworkUrl}?t=${Date.now()}`;
          const videoElement = document.getElementById("album_video");
          const videoSource = document.getElementById("video_source");

          if (hevcUrl) {
            if (videoSource.src !== hevcUrl) {
              // Show fallback image briefly while video loads
              imgContainer.classList.remove("hidden");
              imgElement.classList.remove("hidden");
              imgElement.src = `${fallbackUrl}?fallback=${Date.now()}`;

              // Then load the HEVC video
              videoSource.src = hevcUrl;
              videoElement.load();

              // Switch to video only when it's ready to render
              videoElement.onloadeddata = () => {
                videoContainer.classList.remove("hidden");
                videoElement.classList.remove("hidden");
                imgContainer.classList.add("hidden");
                imgElement.classList.add("hidden");
                imgElement.src = "";
              };
            } else {
              videoContainer.classList.remove("hidden");
              videoElement.classList.remove("hidden");
              imgContainer.classList.add("hidden");
              imgElement.classList.add("hidden");
              imgElement.src = "";
            }
          } else {
            // Preload static/fallback image, then show
            videoContainer.classList.add("hidden");
            videoElement.classList.add("hidden");
            imgContainer.classList.remove("hidden");
            // Only preload if URL changed
            const currentImgUrl = imgElement.src.split("?")[0];
            if (currentImgUrl !== finalArtworkUrl) {
              imgElement.classList.remove("hidden");
              imgElement.src = `${fallbackUrl}?fallback=${Date.now()}`;
              imgElement.style.objectFit = "contain";

              function forceArtworkSize(url, callback) {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = function () {
                  const canvas = document.createElement("canvas");
                  canvas.width = 3000;
                  canvas.height = 3000;
                  const ctx = canvas.getContext("2d");
                  ctx.drawImage(img, 0, 0, 3000, 3000);
                  const resizedDataUrl = canvas.toDataURL("image/png");
                  callback(resizedDataUrl);
                };
                img.src = url;
              }

              const preloadImg = new Image();
              preloadImg.crossOrigin = "anonymous";
              preloadImg.onload = () => {
                forceArtworkSize(newSrc, (resizedUrl) => {
                  imgElement.src = resizedUrl;
                  imgElement.style.objectFit = "contain";
                });
              };
              preloadImg.onerror = () => {
                // Fallback already shown
              };
              preloadImg.src = newSrc;
            } else {
              imgElement.classList.remove("hidden");
            }
          }
          } // end artwork/video update guard

          // Update audio info
          const sampleRateElem = document.getElementById("sampleRate");
          const bitDepthElem = document.getElementById("bitDepth");
          const audioInfoElem = document.getElementById("audioInfo");
          if (data.info.sample_rate) {
            const sr = data.info.sample_rate / 1000;
            sampleRateElem.textContent = (sr % 1 === 0) ? sr.toFixed(0) : sr.toFixed(1);
            bitDepthElem.textContent = data.info.bitdepth || "—";

            const losslessIcon = document.querySelector("#audioInfo img");
            const rendition = data.info.rendition || "";

            if (rendition === "Lossless") {
              const label = sr > 48 ? "Hi-Res Lossless" : "Lossless";
              document.getElementById("audioLabel").textContent = label;

              if (losslessIcon) {
                losslessIcon.src = "../static/images/lossless.png";
                losslessIcon.classList.remove("hidden");
              }

              if (sr > 48) {
                audioInfoElem.style.color = "black";
                audioInfoElem.style.backgroundColor = "#dea442";
                audioInfoElem.style.borderColor = "#dea442";
              } else {
                audioInfoElem.style.color = "black";
                audioInfoElem.style.backgroundColor = "white";
                audioInfoElem.style.borderColor = "white";
              }
            } else {
              document.getElementById("audioLabel").textContent = "AAC";
              bitDepthElem.textContent = "16";
              if (losslessIcon) {
                losslessIcon.src = "";
                losslessIcon.classList.add("hidden");
              }
              audioInfoElem.style.color = "white";
              audioInfoElem.style.backgroundColor = "transparent";
              audioInfoElem.style.borderColor = "white";
            }
          } else {
            sampleRateElem.textContent = "—";
            bitDepthElem.textContent = "—";
            document.getElementById("audioLabel").textContent = "Lossless";
            audioInfoElem.style.color = "black";
            audioInfoElem.style.backgroundColor = "white";
            audioInfoElem.style.borderColor = "white";
          }

          // Update device info
          const deviceNameElem = document.getElementById("deviceName");
          if (data.device) {
            deviceNameElem.textContent = data.device.name || "—";
            const deviceSampleRateElem = document.getElementById("deviceSampleRate");
            const deviceBitDepthElem = document.getElementById("deviceBitDepth");
            const dsr = data.device.sample_rate ? data.device.sample_rate / 1000 : null;
            deviceSampleRateElem.textContent = dsr !== null ? ((dsr % 1 === 0) ? dsr.toFixed(0) : dsr.toFixed(1)) : "—";
            deviceBitDepthElem.textContent = data.device.bit_depth || "—";
          }

          // Set Play/Pause button behavior
          const playbackState = data.nowplaying["Playback State"];
          const playPauseBtn = document.getElementById("playPauseBtn");
          if (playPauseBtn) {
          if (playbackState === "Paused") {
            playPauseBtn.onclick = () => sendPlayerCommand("play");
            playPauseBtn.textContent = "⏵";
          } else {
            playPauseBtn.onclick = () => sendPlayerCommand("pause");
            playPauseBtn.textContent = "⏸";
          }
          }

          // Update progress bar
          const duration = data.nowplaying.Duration;
          const position = data.nowplaying.Position;
          const progressBar = document.getElementById("progressBar");
          if (duration && position && progressBar) {
            // Set progress immediately for jumps
            const trackDuration = parseFloat(duration);
            let targetPosition = parseFloat(position);
            if (isNaN(trackDuration) || isNaN(targetPosition)) return;
            let currentAnimatedPosition = targetPosition;

            function animateProgressBar(timestamp) {
              if (playbackState !== "Paused") {
                const delta = targetPosition - currentAnimatedPosition;
                if (Math.abs(delta) > 1) {
                  currentAnimatedPosition += delta * 0.2;
                } else {
                  currentAnimatedPosition += 0.016; // close enough, move smoothly
                  targetPosition += 0.016;
                }
              } else {
                currentAnimatedPosition += (targetPosition - currentAnimatedPosition) * 0.1;
              }

              const clampedPosition = Math.min(Math.max(currentAnimatedPosition, 0), trackDuration);
              const newPercent = (clampedPosition / trackDuration) * 100;
              progressBar.style.width = `${newPercent}%`;

              window._progressRAF = requestAnimationFrame(animateProgressBar);
            }

            cancelAnimationFrame(window._progressRAF);
            window._progressRAF = requestAnimationFrame(animateProgressBar);
          }
        })
        .catch(err => console.error("Error fetching data:", err));
    }

    function startInterval() {
  if (!intervalID) {
    function loop() {
      if ('requestIdleCallback' in window) {
        requestIdleCallback(() => {
          refreshData();
          intervalID = setTimeout(loop, 1000);
        });
      } else {
        refreshData();
        intervalID = setTimeout(loop, 1000);
      }
    }
    loop();
  }
}

    // Add key listener for spacebar to toggle play/pause, and arrow keys for next/previous
    document.addEventListener("keydown", function(event) {
      if (event.code === "Space" && event.target === document.body) {
        event.preventDefault(); // Prevent page scrolling
        const playPauseBtn = document.getElementById("playPauseBtn");
        if (playPauseBtn) {
          playPauseBtn.click();
        }
      } else if (event.code === "ArrowRight") {
        sendPlayerCommand("next");
      } else if (event.code === "ArrowLeft") {
        sendPlayerCommand("previous");
      }
    });

    window.onload = startInterval;
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>
  <script>
    const urlParams = new URLSearchParams(window.location.search);
    const visualizerName = urlParams.get("visualizer") || "visualizer1.js";
    const visualizerScript = document.createElement("script");
    visualizerScript.src = `/static/visualizers/${visualizerName}`;
    visualizerScript.defer = true;
    visualizerScript.id = "dynamicVisualizerScript";
    visualizerScript.onload = () => {
      const canvas = document.getElementById("visualizer-canvas");
      if (canvas) {
        canvas.remove();
      }

      const newCanvas = document.createElement("canvas");
      newCanvas.id = "visualizer-canvas";
      newCanvas.className = "absolute inset-0 w-full h-full z-0";
      document.getElementById("bg-image").prepend(newCanvas);

      if (window.initVisualizer) {
        console.log("Calling initVisualizer() on initial load");
        window.initVisualizer();
      } else {
        console.warn("initVisualizer not defined on initial load");
      }
    };
    document.head.appendChild(visualizerScript);
  </script>
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const select = document.getElementById("visualizerSelect");
      if (select) {
        select.addEventListener("change", function () {
          const selected = this.value;
          const searchParams = new URLSearchParams(window.location.search);
          searchParams.set("visualizer", selected);
          window.location.search = searchParams.toString();
        });
      }
    });
  </script>
  </head>
<body class="bg-black text-white flex flex-col justify-center items-center min-h-screen w-full relative">

  <!-- 1) Background image that will be faded in/out via JS -->
  <div id="bg-image" class="absolute inset-0 fade-transition z-0">
    <canvas id="visualizer-canvas" class="absolute inset-0 w-full h-full z-0"></canvas>
  </div>

  <!-- 2) Global frosted-glass overlay (container for dynamic overlay) -->
  <div id="visualizer-overlay" class="absolute inset-0 z-0"></div>

  <!-- 3) Content wrapper (centred in viewport) -->
  <div class="relative z-10 flex items-center justify-center w-full px-[1%] h-screen">

    <!-- Flex container: artwork (left) + metadata (right) -->
    <div class="flex flex-row items-center justify-center w-full max-w-screen-3xl gap-10 px-8 h-[95vh]">

      <!-- ──────────── Artwork section ──────────── -->
      <div id="artwork_section"
           class="flex flex-col items-center justify-center flex-1 h-full fade-transition">

        <!-- HEVC video container (hidden until used) -->
        <div id="video_container"
             class="hidden w-full h-full rounded-[30px] overflow-hidden flex items-center justify-center">
          <video id="album_video"
                 class="object-contain rounded-[30px] max-w-full max-h-full"
                 style="max-width: var(--artwork-max-width); max-height: var(--artwork-max-height);"
                 autoplay loop muted playsinline>
            <source id="video_source" src="" type="video/mp4">
          </video>
        </div>

        <!-- Static artwork image container -->
        <div id="img_container"
             class="hidden w-full h-full rounded-[30px] overflow-hidden flex items-center justify-center">
          <img id="album_art"
               class="object-contain rounded-[30px] max-w-full max-h-full"
               alt="Album Art" />
        </div>
      </div>

      <!-- ──────────── Metadata / info section ──────────── -->
      <div id="metadata_container"
           class="flex flex-col justify-center text-left w-full fade-transition
                  backdrop-blur-[100px] backdrop-saturate-150 bg-white/20 rounded-[30px] shadow-xl"
           style="max-width: var(--metadata-max-width); padding: var(--metadata-padding);">

        <!-- Audio info (sample-rate / bit-depth) -->
        <div id="audioInfo"
             class="text-lg font-medium mb-3 px-3 py-1 rounded-[20px] border inline-flex items-center gap-2 w-fit text-white">
          <img src="../static/images/lossless.png" alt="Lossless Icon" class="inline h-5" />
          <span id="audioLabel">Lossless</span>
          <span><span id="bitDepth">—</span> Bit/<span id="sampleRate">—</span> kHz</span>
        </div>

        <!-- Device info (default output) -->
        <div id="deviceInfo" class="text-base text-white mb-4">
          <span id="deviceName">—</span> —
          <span id="deviceBitDepth">—</span> Bit/<span id="deviceSampleRate">—</span> kHz
        </div>

        <!-- Track metadata -->
        <p id="title"  class="mb-4 text-4xl font-bold text-white break-words">—</p>
        <p id="artist" class="mb-2 text-2xl text-white break-words">—</p>
        <p id="album"  class="mb-2 text-2xl text-white break-words">—</p>

        <!-- Progress bar -->
        <div class="w-full h-2 bg-white/30 rounded-full overflow-hidden mb-4">
          <div id="progressBar" class="h-full bg-white transition-all duration-300" style="width: 0%;"></div>
        </div>

        <!-- Visualizer headline -->
        <div class="text-white text-xl font-semibold text-center mb-2">Visualizer</div>
        <div class="mb-4 text-white flex items-center gap-4 justify-center text-2xl">
          <button id="prevVisualizerBtn" class="hover:text-gray-400 transition" aria-label="Previous Visualizer">&#9664;</button>
          <span class="text-sm" id="currentVisualizerName"></span>
          <button id="nextVisualizerBtn" class="hover:text-gray-400 transition" aria-label="Next Visualizer">&#9654;</button>
        </div>

        <!-- Player controls -->
        <div class="mt-6 flex gap-4 justify-center">
          <div class="text-white" style="font-size: var(--player-button-size, 3.5rem);">
            <button onclick="sendPlayerCommand('previous')" class="hover:opacity-80 transition">⏮</button>
            <button id="playPauseBtn" class="hover:opacity-80 transition">⏯</button>
            <button onclick="sendPlayerCommand('next')" class="hover:opacity-80 transition">⏭</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  <script>
  document.addEventListener("DOMContentLoaded", () => {
    console.log("Fetching /visualizers...");
    fetch("/visualizers")
      .then(res => res.json())
      .then(data => {
        const visualizers = data.visualizers || [];
        const searchParams = new URLSearchParams(window.location.search);
        let current = searchParams.get("visualizer");

        if (!current) {
          const scriptTag = document.getElementById("dynamicVisualizerScript");
          if (scriptTag && scriptTag.src) {
            const parts = scriptTag.src.split("/");
            current = parts[parts.length - 1];
          }
        }

        if (!current || !visualizers.includes(current)) {
          current = visualizers[0];
        }

        let index = visualizers.indexOf(current);
        const label = document.getElementById("currentVisualizerName");
        if (label) {
          label.textContent = window.visualizerName || visualizers[index].replace(".js", "").replace("visualizer", "Visualizer ");
        }

        const prevBtn = document.getElementById("prevVisualizerBtn");
        const nextBtn = document.getElementById("nextVisualizerBtn");
        if (prevBtn) {
          prevBtn.addEventListener("click", () => {
            const newIndex = (visualizers.indexOf(current) - 1 + visualizers.length) % visualizers.length;
            switchVisualizer(newIndex);
          });
        }
        if (nextBtn) {
          nextBtn.addEventListener("click", () => {
            const newIndex = (visualizers.indexOf(current) + 1) % visualizers.length;
            switchVisualizer(newIndex);
          });
        }

        function switchVisualizer(newIndex) {
          const newVisualizer = visualizers[newIndex];
          current = newVisualizer;
          index = newIndex;

          const oldScript = document.getElementById("dynamicVisualizerScript");
          if (oldScript) {
            oldScript.remove();
            window.initVisualizer = null;
          }

          const script = document.createElement("script");
          script.src = `/static/visualizers/${newVisualizer}`;
          script.defer = true;
          script.id = "dynamicVisualizerScript";
          script.onload = () => {
            const oldCanvas = document.querySelector("#visualizer-canvas");
            if (oldCanvas) oldCanvas.remove();

            const newCanvas = document.createElement("canvas");
            newCanvas.id = "visualizer-canvas";
            newCanvas.className = "absolute inset-0 w-full h-full z-0";
            document.getElementById("bg-image").prepend(newCanvas);

            if (window.initVisualizer) {
              window.initVisualizer();
            }

            if (label) {
              label.textContent = window.visualizerName || newVisualizer.replace(".js", "").replace("visualizer", "Visualizer ");
            }
          };

          document.head.appendChild(script);

          const canvas = document.getElementById("visualizer-canvas");
          if (canvas && canvas.getContext) {
            const ctx = canvas.getContext("2d");
            if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
          }

          const newSearchParams = new URLSearchParams(window.location.search);
          newSearchParams.set("visualizer", newVisualizer);
          const newUrl = `${window.location.pathname}?${newSearchParams.toString()}`;
          window.history.replaceState(null, "", newUrl);
        }
      })
      .catch(err => console.error("Failed to fetch visualizers:", err));
  });
  </script>
</body>
</html>